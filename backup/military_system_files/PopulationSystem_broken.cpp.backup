// ============================================================================
// PopulationSystem.cpp - Population Management System Implementation
// Created: December 19, 2024 at 10:50 AM
// Location: src/game/population/PopulationSystem.cpp
// ============================================================================

#include "game/population/PopulationSystem.h"
#include "core/logging/Logger.h"
#include "config/GameConfig.h"
#include "utils/RandomGenerator.h"
#include "core/types/game_types.h"
#include <algorithm>
#include <cmath>
#include <numeric>

namespace game::population {

// ============================================================================
// PopulationSystem Implementation
// ============================================================================

PopulationSystem::PopulationSystem(::core::ecs::ComponentAccessManager& access_manager,
                                   ::core::ecs::MessageBus& message_bus)
    : m_access_manager(access_manager), m_message_bus(message_bus) {
    
    std::random_device rd;
    m_random_generator.seed(rd());
    
    ::core::logging::LogInfo("PopulationSystem", "Population System created");
}

void PopulationSystem::Initialize() {
    if (m_initialized) {
        return;
    }

    ::core::logging::LogInfo("PopulationSystem", "Initializing Population System");

    LoadConfiguration();
    InitializeEventProcessor();
    InitializeFactory();
    SubscribeToEvents();

    m_initialized = true;
    ::core::logging::LogInfo("PopulationSystem", "Population System initialized successfully");
}

void PopulationSystem::Update(float delta_time) {
    if (!m_initialized) {
        ::core::logging::LogWarning("PopulationSystem", "System not initialized, skipping update");
        return;
    }

    m_accumulated_time += delta_time;
    
    // Process demographic changes every game hour
    if (m_accumulated_time >= 1.0f) { // Process every second for now
        ProcessRegularUpdates(m_accumulated_time);
        m_accumulated_time = 0.0f;
    }
}

void PopulationSystem::Shutdown() {
    if (!m_initialized) {
        return;
    }

    ::core::logging::LogInfo("PopulationSystem", "Shutting down Population System");
    
    // Clean up any resources
    m_event_processor.reset();
    m_factory.reset();
    
    m_initialized = false;
}

::core::threading::ThreadingStrategy PopulationSystem::GetThreadingStrategy() const {
    return ::core::threading::ThreadingStrategy::MAIN_THREAD;
}

// Population Management Methods
// ============================================================================

void PopulationSystem::CreateInitialPopulation(game::types::EntityID province_id,
                                               const std::string& culture,
                                               const std::string& religion,
                                               int base_population,
                                               double prosperity_level,
                                               int year) {
    try {
        auto pop_write = m_access_manager.GetWriteAccess<PopulationComponent>("CreatePopulation");
        auto settlement_write = m_access_manager.GetWriteAccess<SettlementComponent>("CreateSettlements");

        // Create population using factory
        PopulationComponent population = m_factory->CreateMedievalPopulation(
            culture, religion, base_population, prosperity_level, year);
        
        // Create settlements using factory
        std::vector<std::string> trade_goods = {"Grain", "Wool", "Iron", "Stone"};
        SettlementComponent settlements = m_factory->CreateMedievalSettlements(
            "Province_" + std::to_string(static_cast<int>(province_id)), 
            base_population, prosperity_level, culture, religion, year, trade_goods);

        // Assign to province
        pop_write->SetComponent(province_id, population);
        settlement_write->SetComponent(province_id, settlements);
        
        ::core::logging::LogInfo("PopulationSystem", 
            "Created initial population for province " + std::to_string(static_cast<int>(province_id)) + 
            " with " + std::to_string(population.total_population) + " people");
    } catch (const std::exception& e) {
        ::core::logging::LogError("PopulationSystem", "Failed to create initial population: " + std::string(e.what()));
    }
}

void PopulationSystem::ProcessDemographicChanges(game::types::EntityID province_id, double yearly_fraction) {
    try {
        auto pop_write = m_access_manager.GetWriteAccess<PopulationComponent>("DemographicChanges");
        
        if (auto population = pop_write->GetComponent(province_id)) {
            // Process natural population growth/decline
            ProcessNaturalGrowth(*population, yearly_fraction);
            
            // Update population statistics
            RecalculateTotalPopulation(*population);
            
            // Send update event
            SendPopulationUpdateEvent(province_id, *population);
        }
    } catch (const std::exception& e) {
        ::core::logging::LogError("PopulationSystem", "Error processing demographic changes: " + std::string(e.what()));
    }
}

void PopulationSystem::ProcessSocialMobility(game::types::EntityID province_id, double yearly_fraction) {
    try {
        auto pop_write = m_access_manager.GetWriteAccess<PopulationComponent>("SocialMobility");
        
        if (auto population = pop_write->GetComponent(province_id)) {
            ProcessClassMobility(*population, province_id, yearly_fraction);
            ProcessLegalStatusChanges(*population, province_id, yearly_fraction);
            
            // Guild advancement requires settlement data
            auto settlement_read = m_access_manager.GetReadAccess<SettlementComponent>("GuildAdvancement");
            if (auto settlements = settlement_read->GetComponent(province_id)) {
                auto settlement_write = m_access_manager.GetWriteAccess<SettlementComponent>("GuildAdvancement");
                ProcessGuildAdvancement(*population, *settlements, province_id, yearly_fraction);
            }
        }
    } catch (const std::exception& e) {
        ::core::logging::LogError("PopulationSystem", "Error processing social mobility: " + std::string(e.what()));
    }
}

void PopulationSystem::ProcessSettlementEvolution(game::types::EntityID province_id, double yearly_fraction) {
    try {
        auto settlement_write = m_access_manager.GetWriteAccess<SettlementComponent>("SettlementEvolution");
        auto pop_read = m_access_manager.GetReadAccess<PopulationComponent>("SettlementEvolution");
        
        if (auto settlements = settlement_write->GetComponent(province_id)) {
            if (auto population = pop_read->GetComponent(province_id)) {
                UpdateSettlementGrowth(*settlements, *population, yearly_fraction);
                UpdateSettlementSpecialization(*settlements, *population);
                
                // Urbanization affects both settlements and population
                auto pop_write = m_access_manager.GetWriteAccess<PopulationComponent>("Urbanization");
                if (auto pop_for_urban = pop_write->GetComponent(province_id)) {
                    UpdateUrbanization(*settlements, *pop_for_urban, yearly_fraction);
                }
            }
        }
    } catch (const std::exception& e) {
        ::core::logging::LogError("PopulationSystem", "Error processing settlement evolution: " + std::string(e.what()));
    }
}

void PopulationSystem::ProcessEmploymentShifts(game::types::EntityID province_id, double yearly_fraction) {
    try {
        auto pop_write = m_access_manager.GetWriteAccess<PopulationComponent>("Employment");
        auto settlement_read = m_access_manager.GetReadAccess<SettlementComponent>("Employment");
        
        if (auto population = pop_write->GetComponent(province_id)) {
            if (auto settlements = settlement_read->GetComponent(province_id)) {
                UpdateEmploymentDistribution(*population, *settlements);
                ProcessJobCreation(*population, *settlements);
            }
        }
    } catch (const std::exception& e) {
        ::core::logging::LogError("PopulationSystem", "Error processing employment shifts: " + std::string(e.what()));
    }
}

// More methods would continue here...
// For brevity, I'll implement the core structure and key methods

} // namespace game::population