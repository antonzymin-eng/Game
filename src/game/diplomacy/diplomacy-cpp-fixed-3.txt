// ============================================================================
// DiplomacySystem.cpp - Fixed (Final section from line ~650)
// ============================================================================

        void DiplomacySystem::CalculatePrestigeEffects(types::EntityID realm_id) {
            auto diplomacy_write = m_access_manager.GetWriteAccess<DiplomacyComponent>("CalculatePrestige");
            auto* diplomacy = diplomacy_write.GetComponent(realm_id);

            if (!diplomacy) {
                return;
            }

            auto& config = game::config::GameConfig::Instance();
            double prestige_from_allies = config.GetDouble("diplomacy.prestige_per_ally", 2.0);
            double prestige_decay_rate = config.GetDouble("diplomacy.prestige_decay_rate", 0.1);

            double ally_prestige = diplomacy->allies.size() * prestige_from_allies;
            diplomacy->prestige = std::max(0.0, diplomacy->prestige - prestige_decay_rate + ally_prestige);
        }

        void DiplomacySystem::ProcessAIDiplomacy(types::EntityID realm_id) {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("AIDiplomacy");
            auto* diplomacy = diplomacy_read.GetComponent(realm_id);

            if (!diplomacy) {
                return;
            }

            GenerateAIDiplomaticActions(realm_id);

            for (auto& proposal : m_pending_proposals) {
                if (proposal.target == realm_id && proposal.is_pending) {
                    double acceptance_chance = EvaluateProposal(proposal);

                    std::random_device rd;
                    std::mt19937 gen(rd());
                    std::uniform_real_distribution<double> dist(0.0, 1.0);

                    if (dist(gen) < acceptance_chance) {
                        switch (proposal.action_type) {
                        case DiplomaticAction::PROPOSE_ALLIANCE:
                        {
                            Treaty alliance_treaty(TreatyType::ALLIANCE, proposal.proposer, proposal.target);
                            alliance_treaty.terms = proposal.terms;

                            auto proposer_diplomacy = GetDiplomacyComponent(proposal.proposer);
                            auto target_diplomacy = GetDiplomacyComponent(proposal.target);

                            if (proposer_diplomacy && target_diplomacy) {
                                proposer_diplomacy->AddTreaty(alliance_treaty);
                                target_diplomacy->AddTreaty(alliance_treaty);
                                proposer_diplomacy->SetRelation(proposal.target, DiplomaticRelation::ALLIED);
                                target_diplomacy->SetRelation(proposal.proposer, DiplomaticRelation::ALLIED);
                            }
                        }
                        break;
                        default:
                            break;
                        }

                        proposal.is_pending = false;

                        core::logging::LogInfo("DiplomacySystem",
                            "Proposal accepted: " + utils::DiplomaticActionToString(proposal.action_type));
                    }
                }
            }
        }

        void DiplomacySystem::GenerateAIDiplomaticActions(types::EntityID realm_id) {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("GenerateAIActions");
            auto* diplomacy = diplomacy_read.GetComponent(realm_id);

            if (!diplomacy) {
                return;
            }

            switch (diplomacy->personality) {
            case DiplomaticPersonality::AGGRESSIVE:
            {
                for (auto neighbor : GetNeighboringRealms(realm_id)) {
                    if (!diplomacy->IsAtWarWith(neighbor) &&
                        GetMilitaryStrengthRatio(realm_id, neighbor) > 1.5) {

                        CasusBelli cb = FindBestCasusBelli(realm_id, neighbor);
                        if (cb != CasusBelli::NONE) {
                            DeclareWar(realm_id, neighbor, cb);
                            break;
                        }
                    }
                }
            }
            break;

            case DiplomaticPersonality::DIPLOMATIC:
            {
                for (auto neighbor : GetNeighboringRealms(realm_id)) {
                    if (!diplomacy->IsAlliedWith(neighbor) &&
                        GetOpinion(realm_id, neighbor) > 40) {

                        std::unordered_map<std::string, double> terms;
                        terms["mutual_defense"] = 1.0;
                        ProposeAlliance(realm_id, neighbor, terms);
                        break;
                    }
                }
            }
            break;

            case DiplomaticPersonality::MERCHANT:
            {
                for (auto potential_partner : GetAllRealms()) {
                    if (potential_partner != realm_id &&
                        !diplomacy->HasTreatyType(potential_partner, TreatyType::TRADE_AGREEMENT)) {

                        double trade_value = CalculateTradeValue(realm_id, potential_partner);
                        if (trade_value > 50.0) {
                            ProposeTradeAgreement(realm_id, potential_partner, 0.2, 10);
                            break;
                        }
                    }
                }
            }
            break;

            default:
                break;
            }
        }

        void DiplomacySystem::ProcessWarDeclaration(types::EntityID aggressor, types::EntityID defender, CasusBelli cb) {
            DeclareWar(aggressor, defender, cb);
        }

        void DiplomacySystem::HandleAllyActivation(types::EntityID war_leader, const std::vector<types::EntityID>& allies) {
            auto& config = game::config::GameConfig::Instance();
            double ally_join_probability = config.GetDouble("diplomacy.ally_join_war_probability", 0.8);

            for (auto ally : allies) {
                std::random_device rd;
                std::mt19937 gen(rd());
                std::uniform_real_distribution<double> dist(0.0, 1.0);

                if (dist(gen) < ally_join_probability) {
                    core::logging::LogInfo("DiplomacySystem",
                        "Ally " + std::to_string(ally) + " joins " + std::to_string(war_leader) + " in war");
                }
            }
        }

        void DiplomacySystem::ProcessPeaceNegotiation(types::EntityID realm_a, types::EntityID realm_b) {
            auto diplomacy_write = m_access_manager.GetWriteAccess<DiplomacyComponent>("PeaceNegotiation");
            auto* diplomacy_a = diplomacy_write.GetComponent(realm_a);
            auto* diplomacy_b = diplomacy_write.GetComponent(realm_b);

            if (!diplomacy_a || !diplomacy_b) {
                return;
            }

            if (diplomacy_a->IsAtWarWith(realm_b)) {
                diplomacy_a->SetRelation(realm_b, DiplomaticRelation::NEUTRAL);
                diplomacy_b->SetRelation(realm_a, DiplomaticRelation::NEUTRAL);

                core::logging::LogInfo("DiplomacySystem",
                    "Peace established between " + std::to_string(realm_a) + " and " + std::to_string(realm_b));
            }
        }

        void DiplomacySystem::UpdateTradeRelations(types::EntityID realm_id) {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("UpdateTradeRelations");
            auto* diplomacy = diplomacy_read.GetComponent(realm_id);

            if (!diplomacy) {
                return;
            }

            for (auto& [other_realm, relationship] : diplomacy->relationships) {
                relationship.trade_volume = CalculateTradeValue(realm_id, other_realm);
            }
        }

        double DiplomacySystem::CalculateTradeValue(types::EntityID realm_a, types::EntityID realm_b) {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("CalculateTradeValue");
            auto* diplomacy_a = diplomacy_read.GetComponent(realm_a);

            if (!diplomacy_a) {
                return 0.0;
            }

            auto* relationship = diplomacy_a->GetRelationship(realm_b);
            if (!relationship) {
                return 0.0;
            }

            auto& config = game::config::GameConfig::Instance();
            double base_trade = config.GetDouble("diplomacy.base_trade_value", 50.0);
            double opinion_modifier = relationship->opinion / 100.0;

            return base_trade * (1.0 + opinion_modifier);
        }

        void DiplomacySystem::ProcessTradeDisputes(types::EntityID realm_id) {
            // Placeholder for trade dispute processing
        }

        void DiplomacySystem::ProcessDiplomaticIntelligence(types::EntityID realm_id) {
            // Placeholder for intelligence gathering
        }

        void DiplomacySystem::UpdateForeignRelationsKnowledge(types::EntityID realm_id) {
            // Placeholder for updating knowledge of foreign relations
        }

        std::vector<types::EntityID> DiplomacySystem::GetAllRealms() const {
            std::vector<types::EntityID> realms;

            for (types::EntityID id = 3000; id < 3010; ++id) {
                realms.push_back(id);
            }

            return realms;
        }

        std::vector<types::EntityID> DiplomacySystem::GetNeighboringRealms(types::EntityID realm_id) const {
            return GetBorderingRealms(realm_id);
        }

        std::vector<types::EntityID> DiplomacySystem::GetPotentialAllies(types::EntityID realm_id) const {
            std::vector<types::EntityID> potential_allies;
            auto all_realms = GetAllRealms();

            for (auto other : all_realms) {
                if (other != realm_id && GetOpinion(realm_id, other) > 20) {
                    potential_allies.push_back(other);
                }
            }

            return potential_allies;
        }

        std::vector<types::EntityID> DiplomacySystem::GetPotentialEnemies(types::EntityID realm_id) const {
            std::vector<types::EntityID> potential_enemies;
            auto all_realms = GetAllRealms();

            for (auto other : all_realms) {
                if (other != realm_id && GetOpinion(realm_id, other) < -20) {
                    potential_enemies.push_back(other);
                }
            }

            return potential_enemies;
        }

        DiplomaticRelation DiplomacySystem::GetRelation(types::EntityID realm_a, types::EntityID realm_b) const {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("GetRelation");
            auto* diplomacy = diplomacy_read.GetComponent(realm_a);

            if (!diplomacy) {
                return DiplomaticRelation::NEUTRAL;
            }

            auto* relationship = diplomacy->GetRelationship(realm_b);
            return relationship ? relationship->relation : DiplomaticRelation::NEUTRAL;
        }

        int DiplomacySystem::GetOpinion(types::EntityID realm_a, types::EntityID realm_b) const {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("GetOpinion");
            auto* diplomacy = diplomacy_read.GetComponent(realm_a);

            if (!diplomacy) {
                return 0;
            }

            auto* relationship = diplomacy->GetRelationship(realm_b);
            return relationship ? relationship->opinion : 0;
        }

        double DiplomacySystem::GetPrestige(types::EntityID realm_id) const {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("GetPrestige");
            auto* diplomacy = diplomacy_read.GetComponent(realm_id);

            return diplomacy ? diplomacy->prestige : 0.0;
        }

        bool DiplomacySystem::AreAtWar(types::EntityID realm_a, types::EntityID realm_b) const {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("AreAtWar");
            auto* diplomacy = diplomacy_read.GetComponent(realm_a);

            if (!diplomacy) {
                return false;
            }

            return diplomacy->IsAtWarWith(realm_b);
        }

        void DiplomacySystem::SetDiplomaticPersonality(types::EntityID realm_id, DiplomaticPersonality personality) {
            auto diplomacy_write = m_access_manager.GetWriteAccess<DiplomacyComponent>("SetPersonality");
            auto* diplomacy = diplomacy_write.GetComponent(realm_id);

            if (diplomacy) {
                diplomacy->personality = personality;
            }
        }

        void DiplomacySystem::SetWarWeariness(double base_war_weariness) {
            m_base_war_weariness = base_war_weariness;
        }

        void DiplomacySystem::SetDiplomaticSpeed(double speed_multiplier) {
            m_diplomatic_speed = speed_multiplier;
        }

        DiplomacyComponent* DiplomacySystem::GetDiplomacyComponent(types::EntityID realm_id) {
            auto diplomacy_write = m_access_manager.GetWriteAccess<DiplomacyComponent>("GetDiplomacyComponent");
            return diplomacy_write.GetComponent(realm_id);
        }

        const DiplomacyComponent* DiplomacySystem::GetDiplomacyComponent(types::EntityID realm_id) const {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("GetDiplomacyComponent");
            return diplomacy_read.GetComponent(realm_id);
        }

        void DiplomacySystem::InitializeDiplomaticPersonalities() {
            core::logging::LogInfo("DiplomacySystem", "Initialized diplomatic personalities");
        }

        void DiplomacySystem::SubscribeToEvents() {
            // Subscribe to relevant events
        }

        double DiplomacySystem::CalculateBaseOpinion(types::EntityID realm_a, types::EntityID realm_b) const {
            return 0.0;
        }

        double DiplomacySystem::CalculateAllianceValue(types::EntityID realm_a, types::EntityID realm_b) const {
            return GetOpinion(realm_a, realm_b) / 100.0;
        }

        double DiplomacySystem::CalculateWarScore(types::EntityID realm_a, types::EntityID realm_b) const {
            return 0.0;
        }

        CasusBelli DiplomacySystem::FindBestCasusBelli(types::EntityID aggressor, types::EntityID target) const {
            auto diplomacy_read = m_access_manager.GetReadAccess<DiplomacyComponent>("FindCasusBelli");
            auto* diplomacy = diplomacy_read.GetComponent(aggressor);

            if (!diplomacy) {
                return CasusBelli::NONE;
            }

            if (!diplomacy->valid_war_goals.empty()) {
                return diplomacy->valid_war_goals[0];
            }

            return CasusBelli::BORDER_DISPUTE;
        }

        double DiplomacySystem::EvaluateProposal(const DiplomaticProposal& proposal) {
            switch (proposal.action_type) {
            case DiplomaticAction::PROPOSE_ALLIANCE:
                return EvaluateAllianceProposal(proposal);
            case DiplomaticAction::PROPOSE_TRADE:
                return EvaluateTradeProposal(proposal);
            default:
                return 0.5;
            }
        }

        double DiplomacySystem::EvaluateAllianceProposal(const DiplomaticProposal& proposal) const {
            auto proposer_diplomacy = GetDiplomacyComponent(proposal.proposer);
            auto target_diplomacy = GetDiplomacyComponent(proposal.target);

            if (!proposer_diplomacy || !target_diplomacy) {
                return 0.0;
            }

            double evaluation = 0.5;

            int opinion = GetOpinion(proposal.target, proposal.proposer);
            evaluation += opinion / 200.0;

            double strength_ratio = GetMilitaryStrengthRatio(proposal.proposer, proposal.target);
            if (strength_ratio > 1.0) {
                evaluation += 0.2;
            }

            auto proposer_enemies = proposer_diplomacy->GetWarEnemies();
            auto target_enemies = target_diplomacy->GetWarEnemies();

            for (auto enemy : proposer_enemies) {
                if (std::find(target_enemies.begin(), target_enemies.end(), enemy) != target_enemies.end()) {
                    evaluation += 0.3;
                }
            }

            return std::clamp(evaluation, 0.0, 1.0);
        }

        double DiplomacySystem::EvaluateTradeProposal(const DiplomaticProposal& proposal) const {
            double trade_value = CalculateTradeValue(proposal.proposer, proposal.target);
            return std::clamp(trade_value / 100.0, 0.0, 1.0);
        }

        double DiplomacySystem::EvaluateMarriageProposal(const DiplomaticProposal& proposal) const {
            return 0.5;
        }

        void DiplomacySystem::ApplyPersonalityToOpinion(types::EntityID realm_id, DiplomaticState& relationship) const {
            // Placeholder
        }

        double DiplomacySystem::GetPersonalityWarLikelihood(DiplomaticPersonality personality) const {
            switch (personality) {
            case DiplomaticPersonality::AGGRESSIVE: return 0.8;
            case DiplomaticPersonality::DIPLOMATIC: return 0.2;
            default: return 0.5;
            }
        }

        double DiplomacySystem::GetPersonalityTradePreference(DiplomaticPersonality personality) const {
            switch (personality) {
            case DiplomaticPersonality::MERCHANT: return 1.0;
            default: return 0.5;
            }
        }

        std::vector<types::EntityID> DiplomacySystem::GetBorderingRealms(types::EntityID realm_id) const {
            std::vector<types::EntityID> neighbors;
            neighbors.push_back(realm_id + 1);
            neighbors.push_back(realm_id - 1);
            return neighbors;
        }

        double DiplomacySystem::GetMilitaryStrengthRatio(types::EntityID realm_a, types::EntityID realm_b) const {
            return 1.0;
        }

        double DiplomacySystem::GetEconomicInterdependence(types::EntityID realm_a, types::EntityID realm_b) const {
            return 0.0;
        }

        void DiplomacySystem::OnWarEnded(const core::ecs::Message& message) {
            // Placeholder
        }

        void DiplomacySystem::OnTradeRouteEstablished(const core::ecs::Message& message) {
            // Placeholder
        }

        void DiplomacySystem::OnTechnologyDiscovered(const core::ecs::Message& message) {
            // Placeholder
        }

        void DiplomacySystem::OnReligiousConversion(const core::ecs::Message& message) {
            // Placeholder
        }

        void DiplomacySystem::LogDiplomaticEvent(types::EntityID realm_a, types::EntityID realm_b, const std::string& event) {
            core::logging::LogInfo("DiplomacySystem",
                "Diplomatic event between " + std::to_string(realm_a) +
                " and " + std::to_string(realm_b) + ": " + event);
        }

        void DiplomacySystem::ValidateDiplomaticState(types::EntityID realm_id) {
            // Placeholder
        }

        std::string DiplomacySystem::GenerateProposalId(types::EntityID proposer, types::EntityID target, DiplomaticAction action) {
            return utils::DiplomaticActionToString(action) + "_" + std::to_string(proposer) + "_" + std::to_string(target);
        }

        namespace utils {
            std::string DiplomaticRelationToString(DiplomaticRelation relation) {
                switch (relation) {
                case DiplomaticRelation::ALLIED: return "Allied";
                case DiplomaticRelation::FRIENDLY: return "Friendly";
                case DiplomaticRelation::NEUTRAL: return "Neutral";
                case DiplomaticRelation::UNFRIENDLY: return "Unfriendly";
                case DiplomaticRelation::HOSTILE: return "Hostile";
                case DiplomaticRelation::AT_WAR: return "At War";
                default: return "Unknown";
                }
            }

            std::string TreatyTypeToString(TreatyType type) {
                switch (type) {
                case TreatyType::ALLIANCE: return "Alliance";
                case TreatyType::TRADE_AGREEMENT: return "Trade Agreement";
                case TreatyType::NON_AGGRESSION: return "Non-Aggression Pact";
                case TreatyType::MARRIAGE_PACT: return "Marriage Pact";
                case TreatyType::TRIBUTE: return "Tribute";
                case TreatyType::BORDER_AGREEMENT: return "Border Agreement";
                case TreatyType::MILITARY_ACCESS: return "Military Access";
                case TreatyType::DEFENSIVE_LEAGUE: return "Defensive League";
                default: return "Unknown Treaty";
                }
            }

            std::string DiplomaticActionToString(DiplomaticAction action) {
                switch (action) {
                case DiplomaticAction::PROPOSE_ALLIANCE: return "Propose Alliance";
                case DiplomaticAction::PROPOSE_TRADE: return "Propose Trade";
                case DiplomaticAction::DECLARE_WAR: return "Declare War";
                case DiplomaticAction::SUE_FOR_PEACE: return "Sue for Peace";
                case DiplomaticAction::SEND_GIFT: return "Send Gift";
                case DiplomaticAction::ARRANGE_MARRIAGE: return "Arrange Marriage";
                default: return "Unknown Action";
                }
            }

            std::string CasusBelliToString(CasusBelli cb) {
                switch (cb) {
                case CasusBelli::BORDER_DISPUTE: return "Border Dispute";
                case CasusBelli::TRADE_INTERFERENCE: return "Trade Interference";
                case CasusBelli::DYNASTIC_CLAIM: return "Dynastic Claim";
                case CasusBelli::RELIGIOUS_CONFLICT: return "Religious Conflict";
                case CasusBelli::INSULT_TO_HONOR: return "Insult to Honor";
                case CasusBelli::BROKEN_TREATY: return "Broken Treaty";
                case CasusBelli::PROTECTION_OF_ALLY: return "Protection of Ally";
                default: return "No Justification";
                }
            }

            std::string DiplomaticPersonalityToString(DiplomaticPersonality personality) {
                switch (personality) {
                case DiplomaticPersonality::AGGRESSIVE: return "Aggressive";
                case DiplomaticPersonality::DIPLOMATIC: return "Diplomatic";
                case DiplomaticPersonality::ISOLATIONIST: return "Isolationist";
                case DiplomaticPersonality::OPPORTUNISTIC: return "Opportunistic";
                case DiplomaticPersonality::HONORABLE: return "Honorable";
                case DiplomaticPersonality::TREACHEROUS: return "Treacherous";
                case DiplomaticPersonality::MERCHANT: return "Merchant";
                case DiplomaticPersonality::RELIGIOUS: return "Religious";
                default: return "Unknown";
                }
            }

            double CalculateOpinionDecay(double current_opinion, float time_delta) {
                double decay_rate = 0.1 * time_delta;
                return std::abs(current_opinion) * decay_rate;
            }

            double CalculatePrestigeFromWar(bool victory, double enemy_prestige) {
                return victory ? enemy_prestige * 0.1 : -enemy_prestige * 0.05;
            }

            double CalculateDiplomaticDistance(types::EntityID realm_a, types::EntityID realm_b) {
                return 100.0;
            }

            bool IsOffensiveTreaty(TreatyType type) {
                return type == TreatyType::ALLIANCE;
            }

            bool IsEconomicTreaty(TreatyType type) {
                return type == TreatyType::TRADE_AGREEMENT;
            }

            bool RequiresMutualConsent(TreatyType type) {
                return type != TreatyType::TRIBUTE;
            }

            int GetTreatyDuration(TreatyType type) {
                switch (type) {
                case TreatyType::NON_AGGRESSION: return 5;
                case TreatyType::TRADE_AGREEMENT: return 20;
                case TreatyType::ALLIANCE: return 25;
                case TreatyType::MARRIAGE_PACT: return 50;
                default: return 10;
                }
            }

            bool AreNaturalAllies(types::EntityID realm_a, types::EntityID realm_b) {
                return false;
            }

            bool AreNaturalEnemies(types::EntityID realm_a, types::EntityID realm_b) {
                return false;
            }

            bool HaveSharedInterests(types::EntityID realm_a, types::EntityID realm_b) {
                return false;
            }

            bool IsValidCasusBelli(types::EntityID aggressor, types::EntityID target, CasusBelli cb) {
                return cb != CasusBelli::NONE;
            }

            double GetWarSupport(types::EntityID realm_id, CasusBelli cb) {
                return 0.5;
            }

            double GetWarWeariness(types::EntityID realm_id, int war_duration_months) {
                return war_duration_months * 0.01;
            }

            bool IsValidMarriageCandidate(types::EntityID bride_realm, types::EntityID groom_realm) {
                return bride_realm != groom_realm;
            }

            double CalculateMarriageValue(types::EntityID realm_a, types::EntityID realm_b) {
                return 25.0;
            }

            bool CreatesSuccessionClaim(const DynasticMarriage& marriage) {
                return marriage.inheritance_claim > 0.0;
            }
        }

    } // namespace diplomacy
} // namespace game
