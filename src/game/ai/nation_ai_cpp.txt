            // Emergency measures
            decision.action = EconomicDecision::ADJUST_TAXES;
            decision.parameter = 0.15f; // Increase taxes
            decision.expectedImpact = realm->monthlyIncome * 0.2f;
            QueueEconomicDecision(decision);
        }
    } else if (economicHealth > 2.0f) {
        // Strong economy - consider investments
        if (m_primaryGoal == StrategicGoal::ECONOMIC_GROWTH) {
            EconomicDecision decision;
            decision.action = EconomicDecision::BUILD_INFRASTRUCTURE;
            decision.parameter = realm->treasury * 0.1f; // Invest 10%
            decision.expectedImpact = realm->monthlyIncome * 0.05f;
            QueueEconomicDecision(decision);
        }
    }
}

void NationAI::UpdateDiplomacy() {
    auto* diplomacy = GetDiplomacyComponent();
    if (!diplomacy) return;
    
    // Update relationship scores
    for (auto& [realmId, relation] : diplomacy->relations) {
        float score = relation.opinion / 100.0f; // Normalize to -1 to 1
        
        // Adjust for treaties
        if (relation.hasAlliance) score += 0.5f;
        if (relation.atWar) score -= 1.0f;
        if (relation.hasTradeAgreement) score += 0.2f;
        
        m_relationshipScores[realmId] = score;
        
        // Consider diplomatic actions
        if (score < -0.5f && !relation.atWar) {
            // Hostile but not at war - prepare
            auto threat = AssessThreat(realmId);
            if (threat >= ThreatLevel::MODERATE) {
                // Seek allies against threat
                DiplomaticDecision decision;
                decision.action = DiplomaticDecision::FORM_ALLIANCE;
                //// Created: September 25, 2025, 12:00 PM
// Location: src/game/ai/NationAI.cpp

#include "game/ai/NationAI.h"
#include "game/realm/RealmManager.h"
#include <algorithm>
#include <iostream>
#include <cmath>

namespace AI {

// ============================================================================
// NationAI Implementation
// ============================================================================

NationAI::NationAI(
    uint32_t actorId,
    types::EntityID realmId,
    const std::string& name,
    CharacterArchetype personality)
    : m_actorId(actorId)
    , m_realmId(realmId)
    , m_name(name)
    , m_personality(personality) {
    
    // Set personality-based defaults
    switch (personality) {
        case CharacterArchetype::THE_CONQUEROR:
        case CharacterArchetype::WARRIOR_KING:
            m_aggressiveness = 0.8f;
            m_riskTolerance = 0.7f;
            m_primaryGoal = StrategicGoal::EXPANSION;
            m_secondaryGoal = StrategicGoal::CONSOLIDATION;
            break;
            
        case CharacterArchetype::THE_DIPLOMAT:
            m_aggressiveness = 0.3f;
            m_riskTolerance = 0.4f;
            m_primaryGoal = StrategicGoal::DIPLOMATIC_DOMINANCE;
            m_secondaryGoal = StrategicGoal::ECONOMIC_GROWTH;
            break;
            
        case CharacterArchetype::THE_MERCHANT:
            m_aggressiveness = 0.2f;
            m_riskTolerance = 0.5f;
            m_primaryGoal = StrategicGoal::ECONOMIC_GROWTH;
            m_secondaryGoal = StrategicGoal::TECHNOLOGICAL_ADVANCEMENT;
            break;
            
        case CharacterArchetype::THE_SCHOLAR:
            m_aggressiveness = 0.1f;
            m_riskTolerance = 0.3f;
            m_primaryGoal = StrategicGoal::TECHNOLOGICAL_ADVANCEMENT;
            m_secondaryGoal = StrategicGoal::CULTURAL_SUPREMACY;
            break;
            
        case CharacterArchetype::THE_BUILDER:
            m_aggressiveness = 0.3f;
            m_riskTolerance = 0.4f;
            m_primaryGoal = StrategicGoal::CONSOLIDATION;
            m_secondaryGoal = StrategicGoal::ECONOMIC_GROWTH;
            break;
            
        default:
            m_aggressiveness = 0.5f;
            m_riskTolerance = 0.5f;
            m_primaryGoal = StrategicGoal::CONSOLIDATION;
            m_secondaryGoal = StrategicGoal::ECONOMIC_GROWTH;
            break;
    }
    
    m_lastActivityTime = std::chrono::system_clock::now();
    m_lastStrategicReview = m_lastActivityTime;
}

// ============================================================================
// Core AI Processing
// ============================================================================

void NationAI::ProcessInformation(const InformationPacket& packet) {
    // Remember the event
    RememberEvent(packet);
    
    // React based on information type and relevance
    switch (packet.type) {
        case InformationType::MILITARY_ACTION:
            // Potential threat or opportunity
            if (packet.originatorEntityId != m_realmId) {
                UpdateThreats();
                
                // If high severity, consider military response
                if (packet.severity > 0.7f) {
                    auto decision = EvaluateMilitaryNeeds();
                    if (decision.action == MilitaryDecision::RAISE_LEVIES) {
                        QueueMilitaryDecision(decision);
                    }
                }
            }
            break;
            
        case InformationType::DIPLOMATIC_CHANGE:
            // Update relationship assessments
            UpdateDiplomacy();
            break;
            
        case InformationType::ECONOMIC_CRISIS:
            // Economic opportunity or threat
            if (packet.severity > 0.6f) {
                auto decision = EvaluateEconomicPolicy();
                QueueEconomicDecision(decision);
            }
            break;
            
        case InformationType::SUCCESSION_CRISIS:
            // Opportunity for expansion or alliance
            if (packet.originatorEntityId != m_realmId) {
                auto warDecision = EvaluateWarDecision(packet.originatorEntityId);
                if (warDecision.shouldDeclare && warDecision.expectedSuccess > 0.6f) {
                    QueueWarDecision(warDecision);
                }
            }
            break;
            
        case InformationType::REBELLION:
            // Weakness to exploit or internal problem
            if (packet.sourceProvinceId != 0) {
                auto* realm = GetRealmComponent();
                if (realm) {
                    // Check if it's our province
                    auto& provinces = realm->ownedProvinces;
                    if (std::find(provinces.begin(), provinces.end(), 
                                 packet.sourceProvinceId) != provinces.end()) {
                        // Internal rebellion - military response
                        auto decision = EvaluateMilitaryNeeds();
                        decision.action = MilitaryDecision::MOVE_ARMIES;
                        decision.targetLocation = packet.sourceProvinceId;
                        QueueMilitaryDecision(decision);
                    }
                }
            }
            break;
            
        default:
            break;
    }
    
    // Periodic strategic review
    auto now = std::chrono::system_clock::now();
    auto timeSinceReview = std::chrono::duration_cast<std::chrono::hours>(
        now - m_lastStrategicReview).count();
    
    if (timeSinceReview > 24) { // Daily strategic review
        UpdateStrategy();
        m_lastStrategicReview = now;
    }
}

void NationAI::UpdateStrategy() {
    // Reassess strategic goals based on current situation
    auto* realm = GetRealmComponent();
    if (!realm) return;
    
    // Check survival conditions
    if (realm->stability < 0.3f || realm->treasury < 100.0) {
        m_primaryGoal = StrategicGoal::SURVIVAL;
        m_aggressiveness *= 0.5f; // Reduce aggression when struggling
        return;
    }
    
    // Evaluate goal achievement
    switch (m_primaryGoal) {
        case StrategicGoal::EXPANSION:
            // Check if we've expanded recently
            if (realm->ownedProvinces.size() > 10) {
                // Switch to consolidation after expansion
                m_primaryGoal = StrategicGoal::CONSOLIDATION;
                m_secondaryGoal = StrategicGoal::EXPANSION;
            }
            break;
            
        case StrategicGoal::ECONOMIC_GROWTH:
            // Check economic health
            if (realm->treasury > 10000.0) {
                // Wealthy enough, consider expansion
                if (m_aggressiveness > 0.5f) {
                    m_primaryGoal = StrategicGoal::EXPANSION;
                } else {
                    m_primaryGoal = StrategicGoal::TECHNOLOGICAL_ADVANCEMENT;
                }
            }
            break;
            
        case StrategicGoal::CONSOLIDATION:
            // Check if realm is stable
            if (realm->stability > 0.8f && realm->legitimacy > 0.8f) {
                // Well consolidated, pursue secondary goal
                std::swap(m_primaryGoal, m_secondaryGoal);
            }
            break;
            
        default:
            break;
    }
    
    // Adjust personality weights based on recent events
    AdjustPersonalityWeights();
    
    // Set new goals if needed
    SetStrategicGoals();
}

void NationAI::ExecuteDecisions() {
    // Execute queued decisions in priority order
    
    // War decisions (highest priority)
    if (!m_warDecisions.empty()) {
        auto decision = m_warDecisions.front();
        m_warDecisions.pop();
        ExecuteWarDeclaration(decision);
    }
    
    // Military decisions
    if (!m_militaryDecisions.empty()) {
        auto decision = m_militaryDecisions.front();
        m_militaryDecisions.pop();
        ExecuteMilitaryAction(decision);
    }
    
    // Diplomatic decisions
    if (!m_diplomaticDecisions.empty()) {
        auto decision = m_diplomaticDecisions.front();
        m_diplomaticDecisions.pop();
        ExecuteDiplomaticAction(decision);
    }
    
    // Economic decisions (lowest priority)
    if (!m_economicDecisions.empty()) {
        auto decision = m_economicDecisions.front();
        m_economicDecisions.pop();
        ExecuteEconomicPolicy(decision);
    }
    
    m_decisionsExecuted++;
}

// ============================================================================
// Background Updates
// ============================================================================

void NationAI::UpdateEconomy() {
    auto* realm = GetRealmComponent();
    if (!realm) return;
    
    // Evaluate economic health
    float economicHealth = realm->treasury / std::max(1.0, realm->monthlyExpenses * 12.0);
    
    if (economicHealth < 0.5f) {
        // Poor economy - need to act
        auto decision = EvaluateEconomicPolicy();
        
        if (realm->treasury < realm->monthlyExpenses * 3) {
            // Emergency measures
            decision.action = EconomicDecision::ADJUST
// Continuation of NationAI.cpp from UpdateEconomy method

            decision.action = EconomicDecision::ADJUST_TAXES;
            decision.parameter = 0.15f; // Increase taxes
            decision.expectedImpact = realm->monthlyIncome * 0.2f;
            QueueEconomicDecision(decision);
        }
    } else if (economicHealth > 2.0f) {
        // Strong economy - consider investments
        if (m_primaryGoal == StrategicGoal::ECONOMIC_GROWTH) {
            EconomicDecision decision;
            decision.action = EconomicDecision::BUILD_INFRASTRUCTURE;
            decision.parameter = realm->treasury * 0.1f; // Invest 10%
            decision.expectedImpact = realm->monthlyIncome * 0.05f;
            QueueEconomicDecision(decision);
        }
    }
}

void NationAI::UpdateDiplomacy() {
    auto* diplomacy = GetDiplomacyComponent();
    if (!diplomacy) return;
    
    // Update relationship scores
    for (auto& [realmId, relation] : diplomacy->relations) {
        float score = relation.opinion / 100.0f; // Normalize to -1 to 1
        
        // Adjust for treaties
        if (relation.hasAlliance) score += 0.5f;
        if (relation.atWar) score -= 1.0f;
        if (relation.hasTradeAgreement) score += 0.2f;
        
        m_relationshipScores[realmId] = score;
        
        // Consider diplomatic actions
        if (score < -0.5f && !relation.atWar) {
            // Hostile but not at war - prepare
            auto threat = AssessThreat(realmId);
            if (threat >= ThreatLevel::MODERATE) {
                // Seek allies against threat
                for (auto& [otherId, otherScore] : m_relationshipScores) {
                    if (otherId != realmId && otherScore > 0.3f) {
                        DiplomaticDecision decision;
                        decision.action = DiplomaticDecision::FORM_ALLIANCE;
                        decision.targetRealm = otherId;
                        decision.expectedBenefit = 0.5f;
                        QueueDiplomaticDecision(decision);
                        break;
                    }
                }
            }
        } else if (score > 0.7f && !relation.hasAlliance) {
            // Very friendly - consider alliance
            auto decision = EvaluateDiplomacy(realmId);
            if (decision.action == DiplomaticDecision::FORM_ALLIANCE) {
                QueueDiplomaticDecision(decision);
            }
        }
    }
}

void NationAI::UpdateMilitary() {
    auto* realm = GetRealmComponent();
    if (!realm) return;
    
    // Calculate military readiness
    float totalForces = realm->levySize + realm->standingArmy;
    float militaryReadiness = totalForces / std::max(1.0f, realm->ownedProvinces.size() * 200.0f);
    
    // Update based on strategic goals
    if (m_primaryGoal == StrategicGoal::EXPANSION) {
        if (militaryReadiness < 0.7f) {
            // Need more troops for expansion
            MilitaryDecision decision;
            decision.action = MilitaryDecision::RAISE_LEVIES;
            decision.targetSize = realm->ownedProvinces.size() * 300;
            QueueMilitaryDecision(decision);
        }
    } else if (m_primaryGoal == StrategicGoal::SURVIVAL) {
        // Defensive preparations
        if (militaryReadiness < 0.5f) {
            MilitaryDecision decision;
            decision.action = MilitaryDecision::HIRE_MERCENARIES;
            decision.targetSize = 500;
            QueueMilitaryDecision(decision);
        }
    }
}

void NationAI::UpdateThreats() {
    auto* diplomacy = GetDiplomacyComponent();
    if (!diplomacy) return;
    
    // Clear old assessments
    m_threatAssessment.clear();
    
    for (const auto& [realmId, relation] : diplomacy->relations) {
        ThreatLevel threat = AssessThreat(realmId);
        m_threatAssessment[realmId] = threat;
        
        // React to high threats
        if (threat >= ThreatLevel::SEVERE && !relation.atWar) {
            // Consider preemptive action
            if (m_aggressiveness > 0.6f && m_riskTolerance > 0.5f) {
                auto warDecision = EvaluateWarDecision(realmId);
                if (warDecision.shouldDeclare) {
                    QueueWarDecision(warDecision);
                }
            } else {
                // Defensive preparations
                MilitaryDecision military;
                military.action = MilitaryDecision::BUILD_FORTIFICATIONS;
                QueueMilitaryDecision(military);
            }
        }
    }
}

// ============================================================================
// Decision Making
// ============================================================================

WarDecision NationAI::EvaluateWarDecision(types::EntityID target) {
    WarDecision decision;
    decision.targetRealm = target;
    
    // Calculate relative strength
    float relativeStrength = CalculateRelativeStrength(target);
    decision.expectedSuccess = std::min(1.0f, relativeStrength * 0.7f);
    
    // Estimate costs
    auto* realm = GetRealmComponent();
    if (realm) {
        decision.expectedCost = realm->monthlyExpenses * 12.0f; // 1 year of war
    }
    
    // Determine if we should declare
    float desirability = CalculateWarDesirability(target);
    float threshold = 0.5f - (m_aggressiveness * 0.3f); // More aggressive = lower threshold
    
    decision.shouldDeclare = (desirability > threshold && 
                             decision.expectedSuccess > 0.4f &&
                             decision.expectedCost < realm->treasury * 0.5f);
    
    // Determine casus belli
    decision.justification = game::realm::CasusBelli::CONQUEST; // Default
    
    return decision;
}

DiplomaticDecision NationAI::EvaluateDiplomacy(types::EntityID target) {
    DiplomaticDecision decision;
    decision.targetRealm = target;
    
    // Get current relationship
    float relationshipScore = 0.0f;
    auto it = m_relationshipScores.find(target);
    if (it != m_relationshipScores.end()) {
        relationshipScore = it->second;
    }
    
    // Determine best action based on relationship and goals
    if (relationshipScore > 0.5f) {
        decision.action = DiplomaticDecision::FORM_ALLIANCE;
        decision.expectedBenefit = CalculateAllianceValue(target);
    } else if (relationshipScore > 0.0f) {
        decision.action = DiplomaticDecision::OFFER_TRADE;
        decision.expectedBenefit = CalculateTradeValue(target);
    } else if (relationshipScore < -0.5f) {
        decision.action = DiplomaticDecision::DENOUNCE;
        decision.expectedBenefit = 0.1f; // Minor benefit from denouncing enemies
    } else {
        decision.action = DiplomaticDecision::IMPROVE_RELATIONS;
        decision.expectedBenefit = 0.2f;
    }
    
    return decision;
}

EconomicDecision NationAI::EvaluateEconomicPolicy() {
    EconomicDecision decision;
    
    auto* realm = GetRealmComponent();
    if (!realm) return decision;
    
    float economicPressure = realm->monthlyExpenses / std::max(1.0, realm->monthlyIncome);
    
    if (economicPressure > 1.2f) {
        // Deficit - need revenue
        decision.action = EconomicDecision::ADJUST_TAXES;
        decision.parameter = 0.02f; // Increase by 2%
        decision.expectedImpact = realm->monthlyIncome * 0.1f;
    } else if (economicPressure < 0.5f && realm->treasury > 5000.0) {
        // Surplus - invest
        decision.action = EconomicDecision::BUILD_INFRASTRUCTURE;
        decision.parameter = 1000.0;
        decision.expectedImpact = realm->monthlyIncome * 0.05f;
    } else {
        // Balanced - promote trade
        decision.action = EconomicDecision::PROMOTE_TRADE;
        decision.parameter = 100.0;
        decision.expectedImpact = realm->monthlyIncome * 0.02f;
    }
    
    return decision;
}

MilitaryDecision NationAI::EvaluateMilitaryNeeds() {
    MilitaryDecision decision;
    
    auto* realm = GetRealmComponent();
    if (!realm) return decision;
    
    float totalThreats = 0.0f;
    for (const auto& [realmId, threat] : m_threatAssessment) {
        totalThreats += static_cast<float>(threat) / 4.0f;
    }
    
    float currentStrength = CalculateMilitaryStrength();
    float neededStrength = totalThreats * 1000.0f; // Scale threat to troops
    
    if (currentStrength < neededStrength * 0.7f) {
        // Need more troops
        decision.action = MilitaryDecision::RAISE_LEVIES;
        decision.targetSize = neededStrength - currentStrength;
    } else if (currentStrength > neededStrength * 1.5f) {
        // Too many troops - reduce costs
        decision.action = MilitaryDecision::DISBAND_TROOPS;
        decision.targetSize = currentStrength - neededStrength;
    } else {
        // Adequate troops - improve quality
        decision.action = MilitaryDecision::BUILD_FORTIFICATIONS;
    }
    
    return decision;
}

// ============================================================================
// Threat Evaluation
// ============================================================================

ThreatLevel NationAI::AssessThreat(types::EntityID realm) const {
    // Get relative military strength
    float relativeStrength = CalculateRelativeStrength(realm);
    
    // Get relationship
    float relationship = 0.0f;
    auto it = m_relationshipScores.find(realm);
    if (it != m_relationshipScores.end()) {
        relationship = it->second;
    }
    
    // Calculate threat
    float threatScore = (1.0f / std::max(0.1f, relativeStrength)) * (1.0f - relationship);
    
    if (threatScore > 2.0f) return ThreatLevel::EXISTENTIAL;
    if (threatScore > 1.5f) return ThreatLevel::SEVERE;
    if (threatScore > 1.0f) return ThreatLevel::MODERATE;
    if (threatScore > 0.5f) return ThreatLevel::LOW;
    return ThreatLevel::MINIMAL;
}

float NationAI::CalculateMilitaryStrength() const {
    auto* realm = GetRealmComponent();
    if (!realm) return 0.0f;
    
    float strength = 0.0f;
    strength += realm->levySize * 1.0f;
    strength += realm->standingArmy * 2.0f; // Professional troops worth more
    
    // Adjust for economic support
    float economicMultiplier = std::min(2.0f, realm->treasury / 1000.0f);
    strength *= economicMultiplier;
    
    return strength;
}

float NationAI::CalculateRelativeStrength(types::EntityID other) const {
    float ourStrength = CalculateMilitaryStrength();
    
    // Would need to get other realm's strength through component system
    // For now, estimate
    float theirStrength = ourStrength * 0.8f; // Placeholder
    
    return ourStrength / std::max(1.0f, theirStrength);
}

// ============================================================================
// Helper Methods
// ============================================================================

void NationAI::RememberEvent(const InformationPacket& packet) {
    EventMemory memory;
    memory.type = packet.type;
    memory.severity = packet.severity;
    memory.timestamp = std::chrono::system_clock::now();
    memory.source = packet.originatorEntityId;
    
    m_recentEvents.push_back(memory);
    
    // Prune old memories
    if (m_recentEvents.size() > MAX_EVENT_MEMORY) {
        m_recentEvents.erase(m_recentEvents.begin());
    }
}

game::realm::RealmComponent* NationAI::GetRealmComponent() {
    if (!m_componentAccess) return nullptr;
    
    auto entityManager = m_componentAccess->GetEntityManager();
    if (!entityManager) return nullptr;
    
    // Would need to find entity by realm ID
    // This is a simplified version
    return nullptr; // Placeholder
}

game::realm::DiplomaticRelationsComponent* NationAI::GetDiplomacyComponent() {
    if (!m_componentAccess) return nullptr;
    
    auto entityManager = m_componentAccess->GetEntityManager();
    if (!entityManager) return nullptr;
    
    // Would need to find entity by realm ID
    return nullptr; // Placeholder
}

float NationAI::CalculateWarDesirability(types::EntityID target) const {
    float desirability = m_aggressiveness; // Base on personality
    
    // Adjust for strategic goals
    if (m_primaryGoal == StrategicGoal::EXPANSION) {
        desirability += 0.3f;
    } else if (m_primaryGoal == StrategicGoal::SURVIVAL) {
        desirability -= 0.5f;
    }
    
    // Adjust for threat level
    auto threatIt = m_threatAssessment.find(target);
    if (threatIt != m_threatAssessment.end()) {
        desirability += static_cast<float>(threatIt->second) * 0.1f;
    }
    
    return std::clamp(desirability, 0.0f, 1.0f);
}

} // namespace AI